package ${packageName}

import ${dtoPackage}.${entityName}DTO
import ${servicePackage}.${entityName}Service
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.Parameter
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import io.swagger.v3.oas.annotations.tags.Tag
import org.slf4j.LoggerFactory
import org.springframework.data.domain.Page
import org.springframework.data.domain.Pageable
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.*
import java.net.URI
import java.util.*

/**
 * REST controller for managing ${entityName}.
 */
@RestController
@RequestMapping("/api/${entityApiPath}")
@Tag(name = "${entityName}s", description = "The ${entityName} API")
class ${controllerName}(private val ${serviceVarName}: ${serviceName}) {

    private val log = LoggerFactory.getLogger(${controllerName}::class.java)

    companion object {
        private const val ENTITY_NAME = "${entityNameLower}"
    }

    /**
     * `POST  /api/${entityApiPath}` : Create a new ${entityNameLower}.
     *
     * @param ${entityNameLower}DTO the ${entityNameLower}DTO to create
     * @return the [ResponseEntity] with status `201 (Created)` and with body the new ${entityNameLower}DTO
     */
    @PostMapping
    @Operation(summary = "Create a new ${entityNameLower}", description = "Create a new ${entityNameLower}")
    @ApiResponses(value = [
        ApiResponse(responseCode = "201", description = "${entityName} created successfully"),
        ApiResponse(responseCode = "400", description = "Invalid input")
    ])
    fun create${entityName}(@Valid @RequestBody ${entityNameLower}DTO: ${dtoName}): ResponseEntity<${dtoName}> {
        log.debug("REST request to save ${entityName} : {}", ${entityNameLower}DTO)
        if (${entityNameLower}DTO.id != null) {
            return ResponseEntity.badRequest().build()
        }
        val result = ${serviceVarName}.save(${entityNameLower}DTO)
        return ResponseEntity.created(URI("/api/${entityApiPath}/${'$'}{result.id}")).body(result)
    }

    /**
     * `PUT  /api/${entityApiPath}/:id` : Updates an existing ${entityNameLower}.
     *
     * @param id the id of the ${entityNameLower}DTO to save
     * @param ${entityNameLower}DTO the ${entityNameLower}DTO to update
     * @return the [ResponseEntity] with status `200 (OK)` and with body the updated ${entityNameLower}DTO
     */
    @PutMapping("/{id}")
    @Operation(summary = "Update a ${entityNameLower}", description = "Update an existing ${entityNameLower}")
    @ApiResponses(value = [
        ApiResponse(responseCode = "200", description = "${entityName} updated successfully"),
        ApiResponse(responseCode = "400", description = "Invalid input"),
        ApiResponse(responseCode = "404", description = "${entityName} not found")
    ])
    fun update${entityName}(
        @Parameter(description = "ID of the ${entityNameLower} to update")
        @PathVariable(value = "id", required = false) id: Long?,
        @Valid @RequestBody ${entityNameLower}DTO: ${dtoName}
    ): ResponseEntity<${dtoName}> {
        log.debug("REST request to update ${entityName} : {}, {}", id, ${entityNameLower}DTO)

        if (${entityNameLower}DTO.id == null) {
            return ResponseEntity.badRequest().build()
        }
        if (id != ${entityNameLower}DTO.id) {
            return ResponseEntity.badRequest().build()
        }
        if (!${serviceVarName}.existsById(id!!)) {
            return ResponseEntity.notFound().build()
        }

        val result = ${serviceVarName}.update(${entityNameLower}DTO)
        return ResponseEntity.ok().body(result)
    }

    /**
     * `PATCH  /api/${entityApiPath}/:id` : Partial updates given fields of an existing ${entityNameLower}.
     *
     * @param id the id of the ${entityNameLower}DTO to save
     * @param ${entityNameLower}DTO the ${entityNameLower}DTO to update
     * @return the [ResponseEntity] with status `200 (OK)` and with body the updated ${entityNameLower}DTO
     */
    @PatchMapping(value = ["/{id}"], consumes = ["application/json", "application/merge-patch+json"])
    @Operation(summary = "Partially update a ${entityNameLower}", description = "Partially update an existing ${entityNameLower}")
    fun partialUpdate${entityName}(
        @Parameter(description = "ID of the ${entityNameLower} to update")
        @PathVariable(value = "id", required = false) id: Long?,
        @RequestBody ${entityNameLower}DTO: ${dtoName}
    ): ResponseEntity<${dtoName}> {
        log.debug("REST request to partial update ${entityName} : {}, {}", id, ${entityNameLower}DTO)

        if (${entityNameLower}DTO.id == null) {
            return ResponseEntity.badRequest().build()
        }
        if (id != ${entityNameLower}DTO.id) {
            return ResponseEntity.badRequest().build()
        }
        if (!${serviceVarName}.existsById(id!!)) {
            return ResponseEntity.notFound().build()
        }

        val result = ${serviceVarName}.partialUpdate(${entityNameLower}DTO)
        return result.map { ResponseEntity.ok().body(it) }
            .orElse(ResponseEntity.notFound().build())
    }

    /**
     * `GET  /api/${entityApiPath}` : get all the ${entityNameLower}s.
     *
     * @param pageable the pagination information
     * @return the [ResponseEntity] with status `200 (OK)` and the list of ${entityNameLower}s in body
     */
    @GetMapping
    @Operation(summary = "Get all ${entityNameLower}s", description = "Get all ${entityNameLower}s with pagination")
    @ApiResponse(responseCode = "200", description = "Successful operation")
    fun getAll${entityName}s(@Parameter(hidden = true) pageable: Pageable): ResponseEntity<List<${dtoName}>> {
        log.debug("REST request to get a page of ${entityName}s")
        val page = ${serviceVarName}.findAll(pageable)
        return ResponseEntity.ok().body(page.content)
    }

    /**
     * `GET  /api/${entityApiPath}/:id` : get the "id" ${entityNameLower}.
     *
     * @param id the id of the ${entityNameLower}DTO to retrieve
     * @return the [ResponseEntity] with status `200 (OK)` and with body the ${entityNameLower}DTO, or with status `404 (Not Found)`
     */
    @GetMapping("/{id}")
    @Operation(summary = "Get a ${entityNameLower} by ID", description = "Get a specific ${entityNameLower} by its ID")
    @ApiResponses(value = [
        ApiResponse(responseCode = "200", description = "${entityName} found"),
        ApiResponse(responseCode = "404", description = "${entityName} not found")
    ])
    fun get${entityName}(
        @Parameter(description = "ID of the ${entityNameLower} to retrieve")
        @PathVariable id: Long
    ): ResponseEntity<${dtoName}> {
        log.debug("REST request to get ${entityName} : {}", id)
        val ${entityNameLower}DTO = ${serviceVarName}.findOne(id)
        return ${entityNameLower}DTO.map { ResponseEntity.ok().body(it) }
            .orElse(ResponseEntity.notFound().build())
    }

    /**
     * `DELETE  /api/${entityApiPath}/:id` : delete the "id" ${entityNameLower}.
     *
     * @param id the id of the ${entityNameLower}DTO to delete
     * @return the [ResponseEntity] with status `204 (NO_CONTENT)`
     */
    @DeleteMapping("/{id}")
    @Operation(summary = "Delete a ${entityNameLower}", description = "Delete a ${entityNameLower} by its ID")
    @ApiResponses(value = [
        ApiResponse(responseCode = "204", description = "${entityName} deleted successfully"),
        ApiResponse(responseCode = "404", description = "${entityName} not found")
    ])
    fun delete${entityName}(
        @Parameter(description = "ID of the ${entityNameLower} to delete")
        @PathVariable id: Long
    ): ResponseEntity<Void> {
        log.debug("REST request to delete ${entityName} : {}", id)
        ${serviceVarName}.delete(id)
        return ResponseEntity.noContent().build()
    }

    <#if customMethods?? && customMethods != "">
    ${customMethods}
    </#if>
}
