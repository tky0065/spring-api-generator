package ${packageName!"${basePackage}.config"}

import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.graphql.execution.RuntimeWiringConfigurer
import graphql.schema.GraphQLScalarType
import graphql.schema.Coercing
import java.time.LocalDate
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
<#if imports??>
${imports}
</#if>

/**
 * Configuration class for GraphQL.
 *
 * Generated on ${currentDate?datetime!"now"} by Spring API Generator Plugin.
 */
@Configuration
class ${className!"GraphQLConfig"} {

    /**
     * Configure custom scalars for GraphQL.
     */
    @Bean
    fun runtimeWiringConfigurer(): RuntimeWiringConfigurer {
        return RuntimeWiringConfigurer { wiringBuilder ->
            wiringBuilder
                .scalar(dateScalar())
                .scalar(dateTimeScalar())
        }
    }

    /**
     * Custom scalar for LocalDate.
     */
    private fun dateScalar(): GraphQLScalarType {
        return GraphQLScalarType.newScalar()
            .name("Date")
            .description("Date scalar")
            .coercing(object : Coercing<LocalDate, String> {
                override fun serialize(dataFetcherResult: Any): String {
                    return when (dataFetcherResult) {
                        is LocalDate -> dataFetcherResult.format(DateTimeFormatter.ISO_LOCAL_DATE)
                        else -> throw RuntimeException("Cannot serialize $dataFetcherResult as Date")
                    }
                }

                override fun parseValue(input: Any): LocalDate {
                    return when (input) {
                        is String -> LocalDate.parse(input, DateTimeFormatter.ISO_LOCAL_DATE)
                        else -> throw RuntimeException("Cannot parse $input as Date")
                    }
                }

                override fun parseLiteral(input: Any): LocalDate {
                    return when (input) {
                        is String -> LocalDate.parse(input, DateTimeFormatter.ISO_LOCAL_DATE)
                        else -> throw RuntimeException("Cannot parse literal $input as Date")
                    }
                }
            })
            .build()
    }

    /**
     * Custom scalar for LocalDateTime.
     */
    private fun dateTimeScalar(): GraphQLScalarType {
        return GraphQLScalarType.newScalar()
            .name("DateTime")
            .description("DateTime scalar")
            .coercing(object : Coercing<LocalDateTime, String> {
                override fun serialize(dataFetcherResult: Any): String {
                    return when (dataFetcherResult) {
                        is LocalDateTime -> dataFetcherResult.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME)
                        else -> throw RuntimeException("Cannot serialize $dataFetcherResult as DateTime")
                    }
                }

                override fun parseValue(input: Any): LocalDateTime {
                    return when (input) {
                        is String -> LocalDateTime.parse(input, DateTimeFormatter.ISO_LOCAL_DATE_TIME)
                        else -> throw RuntimeException("Cannot parse $input as DateTime")
                    }
                }

                override fun parseLiteral(input: Any): LocalDateTime {
                    return when (input) {
                        is String -> LocalDateTime.parse(input, DateTimeFormatter.ISO_LOCAL_DATE_TIME)
                        else -> throw RuntimeException("Cannot parse literal $input as DateTime")
                    }
                }
            })
            .build()
    }

<#if customMethods?? && customMethods != "">
${customMethods}
</#if>
}
