package ${packageName!"${basePackage}.controller"}

import org.springframework.web.bind.annotation.*
import org.springframework.http.ResponseEntity
import org.springframework.http.HttpStatus
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.tags.Tag
import java.util.*
<#if imports??>
${imports}
</#if>

/**
 * REST controller for managing ${className!"Entity"} relationships (Kotlin version).
 * Generated by Spring API Generator.
 */
@RestController
@RequestMapping("/api/${entityApiPath!"entities"}")
@Tag(name = "${className!"Entity"} Relationships", description = "${className!"Entity"} relationship management operations")
class ${className!"Entity"}RelationshipController(
    private val ${serviceVarName}: ${serviceName}
) {

    @Operation(summary = "Add relationship", description = "Add a relationship to ${className!"Entity"}")
    @PostMapping("/{id}/relationships/{relationshipType}")
    fun addRelationship(
        @PathVariable id: ${idType!"Long"},
        @PathVariable relationshipType: String,
        @RequestBody relationshipData: Map<String, Any>
    ): ResponseEntity<Map<String, String>> {
        return try {
            val entity = ${serviceVarName}.findOne(id)
                ?: return ResponseEntity.notFound().build()

            // Process relationship addition based on type
            when (relationshipType) {
<#if relationships?? && relationships?has_content>
<#list relationships as relationship>
                "${relationship.fieldName}" -> {
                    // Handle ${relationship.relationType!"NONE"} relationship
                    val targetId = relationshipData["targetId"] as? ${relationship.targetIdType!"Long"}
                    if (targetId != null) {
                        ${serviceVarName}.add${relationship.fieldName?cap_first}(id, targetId)
                    }
                }
</#list>
<#else>
                "defaultRelation" -> {
                    // Handle default relationship
                    val targetId = relationshipData["targetId"] as? Long
                    if (targetId != null) {
                        ${serviceVarName}.addRelation(id, targetId)
                    }
                }
</#if>
                else -> return ResponseEntity.badRequest()
                    .body(mapOf("error" to "Unknown relationship type: $relationshipType"))
            }

            ResponseEntity.ok(mapOf("message" to "Relationship added successfully"))
        } catch (e: Exception) {
            ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(mapOf("error" to (e.message ?: "Unknown error")))
        }
    }

    @Operation(summary = "Remove relationship", description = "Remove a relationship from ${className!"Entity"}")
    @DeleteMapping("/{id}/relationships/{relationshipType}")
    fun removeRelationship(
        @PathVariable id: ${idType!"Long"},
        @PathVariable relationshipType: String,
        @RequestParam targetId: String
    ): ResponseEntity<Map<String, String>> {
        return try {
            val entity = ${serviceVarName}.findOne(id)
                ?: return ResponseEntity.notFound().build()

            // Process relationship removal based on type
            when (relationshipType) {
<#if relationships?? && relationships?has_content>
<#list relationships as relationship>
                "${relationship.fieldName}" -> {
                    ${serviceVarName}.remove${relationship.fieldName?cap_first}(id, targetId)
                }
</#list>
<#else>
                "defaultRelation" -> {
                    ${serviceVarName}.removeRelation(id, targetId)
                }
</#if>
                else -> return ResponseEntity.badRequest()
                    .body(mapOf("error" to "Unknown relationship type: $relationshipType"))
            }

            ResponseEntity.ok(mapOf("message" to "Relationship removed successfully"))
        } catch (e: Exception) {
            ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(mapOf("error" to (e.message ?: "Unknown error")))
        }
    }

    @Operation(summary = "Get relationships", description = "Get all relationships for ${className!"Entity"}")
    @GetMapping("/{id}/relationships")
    fun getRelationships(@PathVariable id: ${idType!"Long"}): ResponseEntity<Map<String, Any>> {
        return try {
            val entity = ${serviceVarName}.findOne(id)
                ?: return ResponseEntity.notFound().build()

            val relationships = mutableMapOf<String, Any>()

<#if relationships?? && relationships?has_content>
<#list relationships as relationship>
<#if relationship.relationType == "ONE_TO_MANY" || relationship.relationType == "MANY_TO_MANY">
            relationships["${relationship.fieldName}"] = entity.${relationship.fieldName}?.map {
                mapOf("id" to it.id, "name" to it.toString())
            } ?: emptyList<Map<String, Any>>()
<#else>
            entity.${relationship.fieldName}?.let {
                relationships["${relationship.fieldName}"] = mapOf("id" to it.id, "name" to it.toString())
            }
</#if>
</#list>
<#else>
            // No relationships defined for this entity
            relationships["message"] = "No relationships defined for ${className!"Entity"}"
</#if>

            ResponseEntity.ok(relationships)
        } catch (e: Exception) {
            ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(mapOf("error" to (e.message ?: "Unknown error")))
        }
    }

    @Operation(summary = "Validate relationships", description = "Validate all relationships for ${className!"Entity"}")
    @GetMapping("/{id}/relationships/validate")
    fun validateRelationships(@PathVariable id: ${idType!"Long"}): ResponseEntity<Map<String, Any>> {
        return try {
            val entity = ${serviceVarName}.findOne(id)
                ?: return ResponseEntity.notFound().build()

<#if relationships?? && relationships?has_content>
            val isValid = entity.validateRelationships()
<#else>
            val isValid = true // No relationships to validate
</#if>
            val result = mapOf(
                "valid" to isValid,
                "entityId" to id,
                "message" to if (isValid) "All relationships are valid" else "Some relationships are invalid"
            )

            ResponseEntity.ok(result)
        } catch (e: Exception) {
            ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(mapOf("error" to (e.message ?: "Unknown error")))
        }
    }

<#if customMethods?? && customMethods != "">
${customMethods}
</#if>
}
