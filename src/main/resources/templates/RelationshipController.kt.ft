package ${packageName}

import org.springframework.web.bind.annotation.*
import org.springframework.http.ResponseEntity
import org.springframework.http.HttpStatus
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.tags.Tag
import java.util.*

/**
 * REST controller for managing ${className} relationships (Kotlin version).
 * Generated by Spring API Generator.
 */
@RestController
@RequestMapping("/api/${entityNameLower}")
@Tag(name = "${className} Relationships", description = "${className} relationship management operations")
class ${className}RelationshipController(
    private val ${entityNameLower}Service: ${className}Service
) {

    @Operation(summary = "Add relationship", description = "Add a relationship to ${className}")
    @PostMapping("/{id}/relationships/{relationshipType}")
    fun addRelationship(
        @PathVariable id: ${idType},
        @PathVariable relationshipType: String,
        @RequestBody relationshipData: Map<String, Any>
    ): ResponseEntity<Map<String, String>> {
        return try {
            val entity = ${entityNameLower}Service.findById(id)
                ?: return ResponseEntity.notFound().build()

            // Process relationship addition based on type
            when (relationshipType) {
                <#list relationships as relationship>
                "${relationship.fieldName}" -> {
                    // Handle ${relationship.relationType} relationship
                    val targetId = relationshipData["targetId"] as? ${relationship.targetEntity?split(".")?last}
                    if (targetId != null) {
                        ${entityNameLower}Service.add${relationship.fieldName?cap_first}(id, targetId)
                    }
                }
                </#list>
                else -> return ResponseEntity.badRequest()
                    .body(mapOf("error" to "Unknown relationship type: $relationshipType"))
            }

            ResponseEntity.ok(mapOf("message" to "Relationship added successfully"))
        } catch (e: Exception) {
            ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(mapOf("error" to e.message.orEmpty()))
        }
    }

    @Operation(summary = "Remove relationship", description = "Remove a relationship from ${className}")
    @DeleteMapping("/{id}/relationships/{relationshipType}")
    fun removeRelationship(
        @PathVariable id: ${idType},
        @PathVariable relationshipType: String,
        @RequestParam targetId: String
    ): ResponseEntity<Map<String, String>> {
        return try {
            val entity = ${entityNameLower}Service.findById(id)
                ?: return ResponseEntity.notFound().build()

            // Process relationship removal based on type
            when (relationshipType) {
                <#list relationships as relationship>
                "${relationship.fieldName}" -> {
                    ${entityNameLower}Service.remove${relationship.fieldName?cap_first}(id, targetId)
                }
                </#list>
                else -> return ResponseEntity.badRequest()
                    .body(mapOf("error" to "Unknown relationship type: $relationshipType"))
            }

            ResponseEntity.ok(mapOf("message" to "Relationship removed successfully"))
        } catch (e: Exception) {
            ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(mapOf("error" to e.message.orEmpty()))
        }
    }

    @Operation(summary = "Get relationships", description = "Get all relationships for ${className}")
    @GetMapping("/{id}/relationships")
    fun getRelationships(@PathVariable id: ${idType}): ResponseEntity<Map<String, Any>> {
        return try {
            val entity = ${entityNameLower}Service.findById(id)
                ?: return ResponseEntity.notFound().build()

            val relationships = mutableMapOf<String, Any>()

            <#list relationships as relationship>
            <#if relationship.relationType == "ONE_TO_MANY" || relationship.relationType == "MANY_TO_MANY">
            relationships["${relationship.fieldName}"] = entity.${relationship.fieldName}?.map {
                mapOf("id" to it.id, "name" to it.toString())
            } ?: emptyList<Map<String, Any>>()
            <#else>
            entity.${relationship.fieldName}?.let {
                relationships["${relationship.fieldName}"] = mapOf("id" to it.id, "name" to it.toString())
            }
            </#if>
            </#list>

            ResponseEntity.ok(relationships)
        } catch (e: Exception) {
            ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(mapOf("error" to e.message.orEmpty()))
        }
    }

    @Operation(summary = "Validate relationships", description = "Validate all relationships for ${className}")
    @GetMapping("/{id}/relationships/validate")
    fun validateRelationships(@PathVariable id: ${idType}): ResponseEntity<Map<String, Any>> {
        return try {
            val entity = ${entityNameLower}Service.findById(id)
                ?: return ResponseEntity.notFound().build()

            val isValid = entity.validateRelationships()
            val result = mapOf(
                "valid" to isValid,
                "entityId" to id,
                "message" to if (isValid) "All relationships are valid" else "Some relationships are invalid"
            )

            ResponseEntity.ok(result)
        } catch (e: Exception) {
            ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(mapOf("error" to e.message.orEmpty()))
        }
    }
}
