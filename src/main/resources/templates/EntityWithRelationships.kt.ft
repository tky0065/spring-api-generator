package ${packageName!"${basePackage}.entity"}

<#-- Generate imports based on relationships -->
<#if relationshipImports?? && relationshipImports?has_content>
<#list relationshipImports as import>
import ${import}
</#list>
</#if>
import jakarta.persistence.*
import java.util.*
<#if imports??>
${imports}
</#if>

/**
 * ${className!"Entity"} entity with enhanced bidirectional relationship management (Kotlin version).
 * Generated by Spring API Generator with automatic relationship synchronization.
 */
@Entity
@Table(name = "${tableName!"${entityNameLower}"}")
data class ${className!"Entity"}(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: ${idType!"Long"}? = null,

<#-- Generate regular fields -->
<#if fields?? && fields?has_content>
<#list fields as field>
<#if field.relationType!"NONE" == "NONE">
<#if field.nullable == false>
    @Column(name = "${field.columnName!field.name}", nullable = false)
<#else>
    @Column(name = "${field.columnName!field.name}")
</#if>
    val ${field.name}: ${field.type}<#if field.nullable>?</#if> = <#if field.nullable>null<#else><#if field.type == "String">""<#elseif field.type == "Boolean">false<#elseif field.type?matches(".*Int.*|.*Long.*|.*Double.*|.*Float.*")>0<#else>null</#if></#if><#if field_has_next>,</#if>
</#if>
</#list>,
</#if>

<#-- Generate relationship fields with proper annotations -->
<#if relationships?? && relationships?has_content>
<#list relationships as relationship>
<#assign targetType = relationship.targetEntity?split(".")?last>
<#assign fieldName = relationship.fieldName>

<#if relationship.relationType == "ONE_TO_MANY">
    @OneToMany(mappedBy = "${relationship.mappedBy!"parent"}", cascade = [CascadeType.ALL])
    val $fieldName: MutableList<$targetType> = mutableListOf()<#if relationship_has_next>,</#if>

<#elseif relationship.relationType == "MANY_TO_ONE">
    @ManyToOne
    @JoinColumn(name = "${relationship.fieldName}_id")
    val $fieldName: $targetType? = null<#if relationship_has_next>,</#if>

<#elseif relationship.relationType == "ONE_TO_ONE">
<#if relationship.isOwnerSide!true>
    @OneToOne(cascade = [CascadeType.ALL])
    @JoinColumn(name = "${relationship.fieldName}_id")
<#else>
    @OneToOne(mappedBy = "${relationship.mappedBy!"parent"}")
</#if>
    val $fieldName: $targetType? = null<#if relationship_has_next>,</#if>

<#elseif relationship.relationType == "MANY_TO_MANY">
<#if relationship.isOwnerSide!true>
    @ManyToMany
    @JoinTable(
        name = "${relationship.joinTable!"${entityNameLower}_${fieldName}"}",
        joinColumns = [JoinColumn(name = "${entityNameLower}_id")],
        inverseJoinColumns = [JoinColumn(name = "${fieldName}_id")]
    )
<#else>
    @ManyToMany(mappedBy = "${relationship.mappedBy!"parent"}")
</#if>
    val $fieldName: MutableSet<$targetType> = mutableSetOf()<#if relationship_has_next>,</#if>
</#if>
</#list>
<#else>
    // No relationships defined
</#if>
) {

<#-- Generate enhanced relationship methods with Kotlin syntax -->
<#if relationships?? && relationships?has_content>
<#list relationships as relationship>
<#assign fieldName = relationship.fieldName>
<#assign targetType = relationship.targetEntity?split(".")?last>

<#if relationship.relationType == "ONE_TO_MANY" || relationship.relationType == "MANY_TO_MANY">
    /**
     * Add ${targetType} to ${fieldName}.
     */
    fun add${fieldName?cap_first?replace("s$", "")}(item: $targetType) {
        $fieldName.add(item)
<#if relationship.isBidirectional!false>
        item.${relationship.inverseFieldName!"parent"} = this
</#if>
    }

    /**
     * Remove ${targetType} from ${fieldName}.
     */
    fun remove${fieldName?cap_first?replace("s$", "")}(item: $targetType) {
        $fieldName.remove(item)
<#if relationship.isBidirectional!false>
        item.${relationship.inverseFieldName!"parent"} = null
</#if>
    }

    /**
     * Clear all ${fieldName}.
     */
    fun clear${fieldName?cap_first}() {
<#if relationship.isBidirectional!false>
        $fieldName.forEach { it.${relationship.inverseFieldName!"parent"} = null }
</#if>
        $fieldName.clear()
    }

    /**
     * Count ${fieldName}.
     */
    fun count${fieldName?cap_first}(): Int = $fieldName.size

    /**
     * Check if has specific ${fieldName?replace("s$", "")} item.
     */
    fun has${fieldName?replace("s$", "")?cap_first}(item: $targetType): Boolean = $fieldName.contains(item)

<#elseif relationship.relationType == "ONE_TO_ONE" || relationship.relationType == "MANY_TO_ONE">
    /**
     * Set ${fieldName}.
     */
    fun set${fieldName?cap_first}(item: $targetType?) {
<#if relationship.isBidirectional!false>
        this.$fieldName?.${relationship.inverseFieldName!"parent"} = null
        item?.${relationship.inverseFieldName!"parent"} = this
</#if>
        this.$fieldName = item
    }

    /**
     * Check if has ${fieldName}.
     */
    fun has${fieldName?cap_first}(): Boolean = $fieldName != null
</#if>
</#list>

    /**
     * Validates the consistency of all bidirectional relationships.
     */
    fun validateRelationships(): Boolean {
        var isValid = true

<#list relationships as relationship>
<#if relationship.isBidirectional!false>
<#assign fieldName = relationship.fieldName>
<#assign inverseFieldName = relationship.inverseFieldName!"parent">

<#if relationship.relationType == "ONE_TO_ONE">
        // Validate ${relationship.fieldName} relationship
        if ($fieldName != null && $fieldName!!.${inverseFieldName} != this) {
            isValid = false
        }
<#elseif relationship.relationType == "ONE_TO_MANY">
        // Validate ${relationship.fieldName} relationship
        for (item in $fieldName) {
            if (item.${inverseFieldName} != this) {
                isValid = false
                break
            }
        }
</#if>
</#if>
</#list>

        return isValid
    }
<#else>
    // No relationship helper methods - no relationships defined
</#if>

    /**
     * Standard equals implementation based on ID.
     */
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is ${className!"Entity"}) return false
        return id == other.id
    }

    /**
     * Standard hashCode implementation based on ID.
     */
    override fun hashCode(): Int = Objects.hash(id)

    /**
     * Enhanced toString with relationship awareness.
     */
    override fun toString(): String {
        return "${className!"Entity"}(" +
                "id=$id" +
<#if fields?? && fields?has_content>
<#list fields as field>
<#if field.relationType!"NONE" == "NONE">
                ", ${field.name}=${field.name}" +
</#if>
</#list>
</#if>
<#if relationships?? && relationships?has_content>
<#list relationships as relationship>
<#assign fieldName = relationship.fieldName>
<#if relationship.relationType == "ONE_TO_ONE" || relationship.relationType == "MANY_TO_ONE">
                ", ${relationship.fieldName}=${$fieldName?.id}" +
<#elseif relationship.relationType == "ONE_TO_MANY" || relationship.relationType == "MANY_TO_MANY">
                ", ${relationship.fieldName}Count=${$fieldName.size}" +
</#if>
</#list>
</#if>
                ")"
    }

<#if customMethods?? && customMethods != "">
${customMethods}
</#if>
}
