package ${packageName}

<#-- Generate imports based on relationships -->
<#list relationshipImports as import>
import ${import}
</#list>
import java.util.*

/**
 * ${className} entity with enhanced bidirectional relationship management (Kotlin version).
 * Generated by Spring API Generator with automatic relationship synchronization.
 */
@Entity
@Table(name = "${tableName}")
class ${className} {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: ${idType}? = null

    <#-- Generate regular fields -->
    <#list fields as field>
    <#if field.relationType == "NONE">
    <#if helpers.validation??>
        <#if field.nullable == false>
    ${helpers.validation("notNull")}
        </#if>
        <#if field.type == "String">
    ${helpers.validation("notBlank")}
        </#if>
    </#if>
    @Column(name = "${field.columnName!field.name}")
    var ${helpers.field.adaptName(field.name)}: ${field.type}<#if field.nullable>?</#if> = <#if field.nullable>null<#else><#if field.type == "String">""<#elseif field.type == "Boolean">false<#elseif field.type?matches(".*Int.*|.*Long.*|.*Double.*|.*Float.*")>0<#else>null</#if></#if>
    </#if>
    </#list>

    <#-- Generate relationship fields with proper annotations -->
    <#list relationships as relationship>
    <#assign targetType = relationship.targetEntity?split(".")?last>
    <#assign fieldName = helpers.field.adaptName(relationship.fieldName)>

    <#if relationship.relationType == "ONE_TO_MANY">
    @OneToMany(mappedBy = "${relationship.mappedBy}", cascade = [CascadeType.ALL])
    var $fieldName: MutableList<$targetType> = mutableListOf()

    <#elseif relationship.relationType == "MANY_TO_ONE">
    @ManyToOne
    @JoinColumn(name = "${relationship.fieldName}_id")
    var $fieldName: $targetType? = null

    <#elseif relationship.relationType == "ONE_TO_ONE">
    @OneToOne(cascade = [CascadeType.ALL])
    <#if relationship.isOwnerSide>
    @JoinColumn(name = "${relationship.fieldName}_id")
    <#else>
    @OneToOne(mappedBy = "${relationship.mappedBy}")
    </#if>
    var $fieldName: $targetType? = null

    <#elseif relationship.relationType == "MANY_TO_MANY">
    <#if relationship.isOwnerSide>
    @ManyToMany
    @JoinTable(
        name = "${relationship.joinTable}",
        joinColumns = [JoinColumn(name = "${relationship.joinColumns[0]}")],
        inverseJoinColumns = [JoinColumn(name = "${relationship.inverseJoinColumns[0]}")]
    )
    <#else>
    @ManyToMany(mappedBy = "${relationship.mappedBy}")
    </#if>
    var $fieldName: MutableSet<$targetType> = mutableSetOf()
    </#if>
    </#list>

    <#-- Generate enhanced relationship methods with Kotlin syntax -->
    <#list relationships as relationship>
    <#assign fieldName = helpers.field.adaptName(relationship.fieldName)>
    <#assign targetType = relationship.targetEntity?split(".")?last>

    <#-- Enhanced methods with bidirectional sync for Kotlin -->
    <#if bidirectionalSyncMethods[relationship.fieldName]??>
        <#assign syncMethod = bidirectionalSyncMethods[relationship.fieldName]>

        <#-- Add method for collections (converted to Kotlin) -->
        <#if syncMethod.addMethod?has_content>
    ${syncMethod.addMethod.replace("public void", "fun").replace("(", "(")?replace(");", ")")?replace("List<", "MutableList<")?replace("Set<", "MutableSet<")?replace("ArrayList<>", "mutableListOf")?replace("HashSet<>", "mutableSetOf")?replace("null", "null")?replace("this.", "")?replace(" {", " {")}
        </#if>

        <#-- Remove method for collections (converted to Kotlin) -->
        <#if syncMethod.removeMethod?has_content>
    ${syncMethod.removeMethod.replace("public void", "fun").replace("(", "(")?replace(");", ")")?replace("List<", "MutableList<")?replace("Set<", "MutableSet<")?replace("this.", "")?replace(" {", " {")}
        </#if>

        <#-- Set method for single relationships (converted to Kotlin) -->
        <#if syncMethod.setMethod?has_content>
    ${syncMethod.setMethod.replace("public void", "fun").replace("(", "(")?replace(");", ")")?replace("this.", "")?replace(" {", " {")?replace("!= null", "!= null")}
        </#if>

        <#-- Clear method for collections (converted to Kotlin) -->
        <#if syncMethod.clearMethod?has_content>
    ${syncMethod.clearMethod.replace("public void", "fun").replace("(", "(")?replace(");", ")")?replace("List<", "MutableList<")?replace("Set<", "MutableSet<")?replace("ArrayList<>", "mutableListOf")?replace("this.", "")?replace(" {", " {")}
        </#if>
    </#if>
    </#list>

    <#-- Generate relationship helper methods (converted to Kotlin) -->
    <#if relationshipHelperMethods?has_content>
    // Relationship helper methods
    <#list relationships as relationship>
    <#assign fieldName = helpers.field.adaptName(relationship.fieldName)>
    <#assign targetType = relationship.targetEntity?split(".")?last>

    <#if relationship.relationType == "ONE_TO_MANY" || relationship.relationType == "MANY_TO_MANY">
    /**
     * Count ${relationship.fieldName}.
     */
    fun count${fieldName?cap_first}(): Int = $fieldName.size

    /**
     * Check if has specific ${relationship.fieldName?replace("s$", "")} item.
     */
    fun has${relationship.fieldName?replace("s$", "")?cap_first}(item: $targetType): Boolean = $fieldName.contains(item)
    </#if>

    <#if relationship.relationType == "ONE_TO_ONE" || relationship.relationType == "MANY_TO_ONE">
    /**
     * Check if has ${relationship.fieldName}.
     */
    fun has${fieldName?cap_first}(): Boolean = $fieldName != null
    </#if>
    </#list>

    /**
     * Validates the consistency of all bidirectional relationships.
     */
    fun validateRelationships(): Boolean {
        var isValid = true

        <#list relationships as relationship>
        <#if relationship.isBidirectional>
        <#assign fieldName = helpers.field.adaptName(relationship.fieldName)>
        <#assign inverseFieldName = relationship.inverseFieldName!"parent">

        <#if relationship.relationType == "ONE_TO_ONE">
        // Validate ${relationship.fieldName} relationship
        if ($fieldName != null && $fieldName!!.${inverseFieldName} != this) {
            isValid = false
        }
        <#elseif relationship.relationType == "ONE_TO_MANY">
        // Validate ${relationship.fieldName} relationship
        for (item in $fieldName) {
            if (item.${inverseFieldName} != this) {
                isValid = false
                break
            }
        }
        </#if>
        </#if>
        </#list>

        return isValid
    }
    </#if>

    <#-- Generate equals and hashCode -->
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is ${className}) return false
        return id == other.id
    }

    override fun hashCode(): Int = Objects.hash(id)

    <#-- Generate toString with relationship awareness -->
    override fun toString(): String {
        return "${className}(" +
            "id=$id" +
            <#list fields as field>
            <#if field.relationType == "NONE">
            ", ${field.name}=${helpers.field.adaptName(field.name)}" +
            </#if>
            </#list>
            <#list relationships as relationship>
            <#assign fieldName = helpers.field.adaptName(relationship.fieldName)>
            <#if relationship.relationType == "ONE_TO_ONE" || relationship.relationType == "MANY_TO_ONE">
            ", ${relationship.fieldName}=${$fieldName?.id}" +
            <#elseif relationship.relationType == "ONE_TO_MANY" || relationship.relationType == "MANY_TO_MANY">
            ", ${relationship.fieldName}Count=${$fieldName.size}" +
            </#if>
            </#list>
            ")"
    }
}
