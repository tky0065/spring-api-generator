package ${packageName};

import ${packageName.replace('.controller', '.entity')}.${className};
import ${packageName.replace('.controller', '.dto')}.${className}DTO;
import ${packageName.replace('.controller', '.service')}.${className}Service;
import ${packageName.replace('.controller', '.mapper')}.${className}Mapper;
import org.springframework.graphql.data.method.annotation.Argument;
import org.springframework.graphql.data.method.annotation.QueryMapping;
import org.springframework.graphql.data.method.annotation.MutationMapping;
import org.springframework.stereotype.Controller;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import reactor.core.publisher.Mono;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * GraphQL Controller for ${className} entity.
 * Contains both Query and Mutation resolvers.
 */
@Controller
public class ${className}GraphQLController {

    private final ${className}Service ${entityNameLower}Service;
    private final ${className}Mapper ${entityNameLower}Mapper;

    public ${className}GraphQLController(${className}Service ${entityNameLower}Service, ${className}Mapper ${entityNameLower}Mapper) {
        this.${entityNameLower}Service = ${entityNameLower}Service;
        this.${entityNameLower}Mapper = ${entityNameLower}Mapper;
    }

    // ========== QUERIES ==========

    /**
     * Get a single ${className} by ID
     */
    @QueryMapping
    public ${className}DTO ${entityNameLower}(@Argument Long id) {
        return ${entityNameLower}Service.findOne(id).orElse(null);
    }

    /**
     * Get all ${className}s with pagination
     */
    @QueryMapping
    public ${className}Page ${entityNameLower}s(
            @Argument int page,
            @Argument int size,
            @Argument String sort,
            @Argument String direction) {

        Sort.Direction sortDirection = "DESC".equalsIgnoreCase(direction)
            ? Sort.Direction.DESC
            : Sort.Direction.ASC;

        PageRequest pageRequest = PageRequest.of(page, size, Sort.by(sortDirection, sort));
        Page<${className}DTO> pageResult = ${entityNameLower}Service.findAll(pageRequest);

        return ${className}Page.builder()
            .content(pageResult.getContent())
            .totalElements((int) pageResult.getTotalElements())
            .totalPages(pageResult.getTotalPages())
            .size(pageResult.getSize())
            .number(pageResult.getNumber())
            .first(pageResult.isFirst())
            .last(pageResult.isLast())
            .build();
    }

    /**
     * Search ${className}s by query
     */
    @QueryMapping
    public ${className}Page search${className}s(
            @Argument String query,
            @Argument int page,
            @Argument int size) {

        // Implementation would depend on your search requirements
        PageRequest pageRequest = PageRequest.of(page, size);
        Page<${className}DTO> pageResult = ${entityNameLower}Service.findAll(pageRequest);

        return ${className}Page.builder()
            .content(pageResult.getContent())
            .totalElements((int) pageResult.getTotalElements())
            .totalPages(pageResult.getTotalPages())
            .size(pageResult.getSize())
            .number(pageResult.getNumber())
            .first(pageResult.isFirst())
            .last(pageResult.isLast())
            .build();
    }

    /**
     * Count total ${className}s
     */
    @QueryMapping
    public int count${className}s() {
        return (int) ${entityNameLower}Service.count();
    }

    // ========== MUTATIONS ==========

    /**
     * Create a new ${className}
     */
    @MutationMapping
    public ${className}DTO create${className}(@Argument Create${className}Input input) {
        ${className}DTO dto = mapCreateInputToDTO(input);
        return ${entityNameLower}Service.save(dto);
    }

    /**
     * Update an existing ${className}
     */
    @MutationMapping
    public ${className}DTO update${className}(@Argument Long id, @Argument Update${className}Input input) {
        Optional<${className}DTO> existingDto = ${entityNameLower}Service.findOne(id);
        if (existingDto.isEmpty()) {
            throw new RuntimeException("${className} not found with id: " + id);
        }

        ${className}DTO dto = mapUpdateInputToDTO(input, existingDto.get());
        return ${entityNameLower}Service.update(dto);
    }

    /**
     * Delete a ${className}
     */
    @MutationMapping
    public boolean delete${className}(@Argument Long id) {
        try {
            ${entityNameLower}Service.delete(id);
            return true;
        } catch (Exception e) {
            return false;
        }
    }

    // ========== HELPER METHODS ==========

    private ${className}DTO mapCreateInputToDTO(Create${className}Input input) {
        ${className}DTO dto = new ${className}DTO();
        // Map fields from input to DTO
${createInputMapping}
        return dto;
    }

    private ${className}DTO mapUpdateInputToDTO(Update${className}Input input, ${className}DTO existingDto) {
        // Update only non-null fields from input
${updateInputMapping}
        return existingDto;
    }

    // ========== INNER CLASSES ==========

    /**
     * Pagination wrapper for GraphQL responses
     */
    public static class ${className}Page {
        private List<${className}DTO> content;
        private int totalElements;
        private int totalPages;
        private int size;
        private int number;
        private boolean first;
        private boolean last;

        public static ${className}PageBuilder builder() {
            return new ${className}PageBuilder();
        }

        // Getters and setters
        public List<${className}DTO> getContent() { return content; }
        public void setContent(List<${className}DTO> content) { this.content = content; }

        public int getTotalElements() { return totalElements; }
        public void setTotalElements(int totalElements) { this.totalElements = totalElements; }

        public int getTotalPages() { return totalPages; }
        public void setTotalPages(int totalPages) { this.totalPages = totalPages; }

        public int getSize() { return size; }
        public void setSize(int size) { this.size = size; }

        public int getNumber() { return number; }
        public void setNumber(int number) { this.number = number; }

        public boolean isFirst() { return first; }
        public void setFirst(boolean first) { this.first = first; }

        public boolean isLast() { return last; }
        public void setLast(boolean last) { this.last = last; }

        public static class ${className}PageBuilder {
            private ${className}Page page = new ${className}Page();

            public ${className}PageBuilder content(List<${className}DTO> content) {
                page.setContent(content);
                return this;
            }

            public ${className}PageBuilder totalElements(int totalElements) {
                page.setTotalElements(totalElements);
                return this;
            }

            public ${className}PageBuilder totalPages(int totalPages) {
                page.setTotalPages(totalPages);
                return this;
            }

            public ${className}PageBuilder size(int size) {
                page.setSize(size);
                return this;
            }

            public ${className}PageBuilder number(int number) {
                page.setNumber(number);
                return this;
            }

            public ${className}PageBuilder first(boolean first) {
                page.setFirst(first);
                return this;
            }

            public ${className}PageBuilder last(boolean last) {
                page.setLast(last);
                return this;
            }

            public ${className}Page build() {
                return page;
            }
        }
    }

    /**
     * Input class for creating ${className}
     */
    public static class Create${className}Input {
${createInputClass}
    }

    /**
     * Input class for updating ${className}
     */
    public static class Update${className}Input {
${updateInputClass}
    }
}
