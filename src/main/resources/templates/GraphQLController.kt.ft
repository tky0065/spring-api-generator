package ${packageName!"${basePackage}.graphql"}

import org.springframework.graphql.data.method.annotation.Argument
import org.springframework.graphql.data.method.annotation.QueryMapping
import org.springframework.graphql.data.method.annotation.MutationMapping
import org.springframework.stereotype.Controller
import org.springframework.data.domain.PageRequest
<#if imports??>
${imports}
</#if>

/**
 * GraphQL Controller for ${entityName} entity.
 * Contains both Query and Mutation resolvers.
 *
 * Generated on ${currentDate?datetime!"now"} by Spring API Generator Plugin.
 */
@Controller
class ${className!"${entityName}GraphQLController"}(
    private val ${serviceVarName}: ${serviceName},
    private val ${mapperVarName}: ${mapperName}
) {

    //---------- QUERIES ----------//

    /**
     * Get a ${entityName} by ID
     *
     * @param id The ID of the ${entityName}
     * @return The ${entityName} DTO or null if not found
     */
    @QueryMapping
    fun ${entityVarName}ById(@Argument id: ${idType!"Long"}): ${dtoName}? {
        return ${serviceVarName}.findOne(id)
    }

    /**
     * Get all ${entityName}s with pagination
     *
     * @param page Page number (default: 0)
     * @param size Page size (default: 20)
     * @return List of ${entityName} DTOs
     */
    @QueryMapping
    fun all${entityName}s(
        @Argument page: Int = 0,
        @Argument size: Int = 20
    ): List<${dtoName}> {
        val pageable = PageRequest.of(page, size)
        return ${serviceVarName}.findAll(pageable).content
    }

    //---------- MUTATIONS ----------//

    /**
     * Create a new ${entityName}
     *
     * @param input The ${entityName} input data
     * @return The created ${entityName} DTO
     */
    @MutationMapping
    fun create${entityName}(@Argument input: ${entityName}Input): ${dtoName} {
        val ${entityVarName}DTO = input.toDTO()
        return ${serviceVarName}.save(${entityVarName}DTO)
    }

    /**
     * Update an existing ${entityName}
     *
     * @param id The ID of the ${entityName} to update
     * @param input The updated ${entityName} data
     * @return The updated ${entityName} DTO
     */
    @MutationMapping
    fun update${entityName}(
        @Argument id: ${idType!"Long"},
        @Argument input: ${entityName}Input
    ): ${dtoName} {
        val ${entityVarName}DTO = input.toDTO().apply { this.id = id }
        return ${serviceVarName}.update(${entityVarName}DTO)
    }

    /**
     * Delete a ${entityName} by ID
     *
     * @param id The ID of the ${entityName} to delete
     * @return true if deleted successfully
     */
    @MutationMapping
    fun delete${entityName}(@Argument id: ${idType!"Long"}): Boolean {
        return try {
            ${serviceVarName}.delete(id)
            true
        } catch (e: Exception) {
            false
        }
    }

    /**
     * Input class for ${entityName} creation and updates
     */
    data class ${entityName}Input(
<#if fields??>
<#list fields as field>
<#if field.name != "id">
        val ${field.name}: ${field.type}<#if field.nullable>?</#if><#if field_has_next>,</#if>
</#if>
</#list>
<#else>
        val name: String? = null
</#if>
    ) {
        fun toDTO(): ${dtoName} {
            return ${dtoName}(
<#if fields??>
<#list fields as field>
<#if field.name == "id">
                id = null<#if field_has_next>,</#if>
<#else>
                ${field.name} = this.${field.name}<#if field_has_next>,</#if>
</#if>
</#list>
<#else>
                id = null,
                name = this.name
</#if>
            )
        }
    }

<#if customMethods?? && customMethods != "">
${customMethods}
</#if>
}
